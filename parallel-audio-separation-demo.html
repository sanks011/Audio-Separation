<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Stream Separator</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            color: white;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .control-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-group h3 {
            margin-top: 0;
            color: #4facfe;
            font-size: 1.2em;
        }
        
        button {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(79, 172, 254, 0.4);
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .slider-container {
            margin: 10px 0;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4facfe;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(79, 172, 254, 0.5);
        }
        
        .visualizer {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .canvas-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
        }
        
        canvas {
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.5);
        }
        
        .status {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 4px solid #4facfe;
        }
        
        .algorithm-info {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .algorithm-info h4 {
            color: #4facfe;
            margin-top: 0;
        }
        
        .recording-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4444;
            display: inline-block;
            margin-right: 8px;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .metric {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #4facfe;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ Real-time Audio Stream Separator</h1>
        
        <div class="control-panel">
            <div class="control-group">
                <h3>üì± Stream Capture</h3>
                <button id="startMic">Start Microphone</button>
                <button id="startSystem">Start System Audio</button>
                <button id="stopAll">Stop All</button>
                <div class="status" id="captureStatus">
                    Ready to capture audio streams
                </div>
            </div>
            
            <div class="control-group">
                <h3>üîß Echo Cancellation</h3>
                <div class="slider-container">
                    <label for="adaptiveGain">Adaptive Filter Gain: <span id="adaptiveGainValue">0.5</span></label>
                    <input type="range" id="adaptiveGain" min="0" max="1" step="0.1" value="0.5">
                </div>
                <div class="slider-container">
                    <label for="noiseGate">Noise Gate Threshold: <span id="noiseGateValue">0.1</span></label>
                    <input type="range" id="noiseGate" min="0" max="1" step="0.05" value="0.1">
                </div>
                <div class="slider-container">
                    <label for="spectralSub">Spectral Subtraction: <span id="spectralSubValue">0.3</span></label>
                    <input type="range" id="spectralSub" min="0" max="1" step="0.1" value="0.3">
                </div>
            </div>
            
            <div class="control-group">
                <h3>üìä Processing Mode</h3>
                <button id="modeAdaptive" class="active">Adaptive Filter</button>
                <button id="modeSpectral">Spectral Subtraction</button>
                <button id="modeCrosscorr">Cross-Correlation</button>
                <button id="modeHybrid">Hybrid Mode</button>
            </div>
        </div>
        
        <div class="visualizer">
            <div class="canvas-container">
                <h4>üé§ Microphone (Raw)</h4>
                <canvas id="micCanvas" width="300" height="150"></canvas>
            </div>
            
            <div class="canvas-container">
                <h4>üñ•Ô∏è System Audio (Raw)</h4>
                <canvas id="systemCanvas" width="300" height="150"></canvas>
            </div>
            
            <div class="canvas-container">
                <h4>üéØ Microphone (Processed)</h4>
                <canvas id="processedMicCanvas" width="300" height="150"></canvas>
            </div>
            
            <div class="canvas-container">
                <h4>üìà Echo Cancellation</h4>
                <canvas id="echoCanvas" width="300" height="150"></canvas>
            </div>
        </div>
        
        <div class="metrics">
            <div class="metric">
                <div class="metric-value" id="echoReduction">0%</div>
                <div>Echo Reduction</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="snrImprovement">0 dB</div>
                <div>SNR Improvement</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="processingLatency">0 ms</div>
                <div>Processing Latency</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="cpuUsage">0%</div>
                <div>CPU Usage</div>
            </div>
        </div>
        
        <div class="algorithm-info">
            <h4>üß† Current Algorithm: Adaptive Echo Cancellation</h4>
            <p id="algorithmDescription">
                Using Normalized Least Mean Squares (NLMS) adaptive filter to predict and subtract echo from microphone signal.
                The algorithm continuously adapts to acoustic coupling between system audio and microphone.
            </p>
        </div>
    </div>

    <script>
        class AudioStreamSeparator {
            constructor() {
                this.micStream = null;
                this.systemStream = null;
                this.audioContext = null;
                this.micAnalyzer = null;
                this.systemAnalyzer = null;
                this.processedAnalyzer = null;
                this.echoAnalyzer = null;
                
                // Processing components
                this.adaptiveFilter = null;
                this.noiseGate = null;
                this.spectralSubtractor = null;
                
                // Audio processing nodes
                this.micSource = null;
                this.systemSource = null;
                this.micGain = null;
                this.systemGain = null;
                this.outputGain = null;
                
                // Processing parameters
                this.params = {
                    adaptiveGain: 0.5,
                    noiseGateThreshold: 0.1,
                    spectralSubtraction: 0.3,
                    processingMode: 'adaptive'
                };
                
                // Performance metrics
                this.metrics = {
                    echoReduction: 0,
                    snrImprovement: 0,
                    processingLatency: 0,
                    cpuUsage: 0
                };
                
                // Processing buffers
                this.micBuffer = new Float32Array(1024);
                this.systemBuffer = new Float32Array(1024);
                this.processedBuffer = new Float32Array(1024);
                this.echoBuffer = new Float32Array(1024);
                
                this.initializeUI();
                this.setupVisualization();
            }
            
            initializeUI() {
                // Stream control buttons
                document.getElementById('startMic').addEventListener('click', () => this.startMicrophone());
                document.getElementById('startSystem').addEventListener('click', () => this.startSystemAudio());
                document.getElementById('stopAll').addEventListener('click', () => this.stopAll());
                
                // Parameter controls
                document.getElementById('adaptiveGain').addEventListener('input', (e) => {
                    this.params.adaptiveGain = parseFloat(e.target.value);
                    document.getElementById('adaptiveGainValue').textContent = e.target.value;
                });
                
                document.getElementById('noiseGate').addEventListener('input', (e) => {
                    this.params.noiseGateThreshold = parseFloat(e.target.value);
                    document.getElementById('noiseGateValue').textContent = e.target.value;
                });
                
                document.getElementById('spectralSub').addEventListener('input', (e) => {
                    this.params.spectralSubtraction = parseFloat(e.target.value);
                    document.getElementById('spectralSubValue').textContent = e.target.value;
                });
                
                // Mode selection
                document.getElementById('modeAdaptive').addEventListener('click', () => this.setProcessingMode('adaptive'));
                document.getElementById('modeSpectral').addEventListener('click', () => this.setProcessingMode('spectral'));
                document.getElementById('modeCrosscorr').addEventListener('click', () => this.setProcessingMode('crosscorr'));
                document.getElementById('modeHybrid').addEventListener('click', () => this.setProcessingMode('hybrid'));
            }
            
            async startMicrophone() {
                try {
                    this.micStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 44100
                        }
                    });
                    
                    this.initializeAudioContext();
                    this.setupMicrophoneProcessing();
                    this.updateStatus('üé§ Microphone active');
                    
                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    this.updateStatus('‚ùå Failed to access microphone');
                }
            }
            
async startSystemAudio() {
    try {
        // Ensure audio constraints are correctly set
        this.systemStream = await navigator.mediaDevices.getDisplayMedia({
            audio: {
                echoCancellation: false,
                noiseSuppression: false,
                autoGainControl: false,
                sampleRate: 44100
            },
            video: true // Required for system audio in some browsers
        });

        // Check if audio tracks are present
        const audioTracks = this.systemStream.getAudioTracks();
        if (audioTracks.length === 0) {
            throw new Error('No audio tracks available in system audio stream');
        }

        this.initializeAudioContext();
        this.setupSystemAudioProcessing();
        this.updateStatus('üñ•Ô∏è System audio active');
    } catch (error) {
        console.error('Error accessing system audio:', error);
        let errorMessage = '‚ùå Failed to access system audio';
        if (error.name === 'NotAllowedError') {
            errorMessage += ': Permission denied. Please allow audio capture in the browser prompt.';
        } else if (error.name === 'NotFoundError') {
            errorMessage += ': No audio source available. Ensure system audio is enabled.';
        } else {
            errorMessage += `: ${error.message}`;
        }
        this.updateStatus(errorMessage);
    }
}
            
            initializeAudioContext() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 44100,
                        latencyHint: 'interactive'
                    });
                    
                    this.setupAudioProcessing();
                }
            }
            
            setupAudioProcessing() {
                // Create analyzers for visualization
                this.micAnalyzer = this.audioContext.createAnalyser();
                this.systemAnalyzer = this.audioContext.createAnalyser();
                this.processedAnalyzer = this.audioContext.createAnalyser();
                this.echoAnalyzer = this.audioContext.createAnalyser();
                
                // Configure analyzers
                [this.micAnalyzer, this.systemAnalyzer, this.processedAnalyzer, this.echoAnalyzer].forEach(analyzer => {
                    analyzer.fftSize = 2048;
                    analyzer.smoothingTimeConstant = 0.8;
                });
                
                // Create gain nodes
                this.micGain = this.audioContext.createGain();
                this.systemGain = this.audioContext.createGain();
                this.outputGain = this.audioContext.createGain();
                
                // Initialize processing components
                this.adaptiveFilter = new AdaptiveFilter(this.audioContext);
                this.noiseGate = new NoiseGate(this.audioContext);
                this.spectralSubtractor = new SpectralSubtractor(this.audioContext);
                
                // Start processing loop
                this.startProcessingLoop();
            }
            
            setupMicrophoneProcessing() {
                if (this.micStream && this.audioContext) {
                    this.micSource = this.audioContext.createMediaStreamSource(this.micStream);
                    this.micSource.connect(this.micGain);
                    this.micGain.connect(this.micAnalyzer);
                    
                    this.startEchoCancellation();
                }
            }
            
            setupSystemAudioProcessing() {
                if (this.systemStream && this.audioContext) {
                    this.systemSource = this.audioContext.createMediaStreamSource(this.systemStream);
                    this.systemSource.connect(this.systemGain);
                    this.systemGain.connect(this.systemAnalyzer);
                    
                    this.startEchoCancellation();
                }
            }
            
            startEchoCancellation() {
                if (this.micSource && this.systemSource) {
                    // Create script processor for real-time processing
                    this.processor = this.audioContext.createScriptProcessor(1024, 2, 1);
                    
                    // Connect inputs
                    this.micGain.connect(this.processor);
                    this.systemGain.connect(this.processor);
                    
                    // Process audio
                    this.processor.onaudioprocess = (event) => {
                        this.processAudio(event);
                    };
                    
                    this.processor.connect(this.processedAnalyzer);
                    this.processor.connect(this.outputGain);
                    
                    this.updateStatus('üéØ Echo cancellation active');
                }
            }
            
            processAudio(event) {
                const startTime = performance.now();
                
                const micInput = event.inputBuffer.getChannelData(0);
                const systemInput = event.inputBuffer.getChannelData(1);
                const output = event.outputBuffer.getChannelData(0);
                
                // Copy to processing buffers
                this.micBuffer.set(micInput);
                this.systemBuffer.set(systemInput);
                
                // Apply selected processing mode
                switch (this.params.processingMode) {
                    case 'adaptive':
                        this.applyAdaptiveFilter(micInput, systemInput, output);
                        break;
                    case 'spectral':
                        this.applySpectralSubtraction(micInput, systemInput, output);
                        break;
                    case 'crosscorr':
                        this.applyCrossCorrelation(micInput, systemInput, output);
                        break;
                    case 'hybrid':
                        this.applyHybridProcessing(micInput, systemInput, output);
                        break;
                }
                
                // Apply noise gate
                this.applyNoiseGate(output);
                
                // Copy to processed buffer for visualization
                this.processedBuffer.set(output);
                
                // Calculate echo reduction
                this.calculateEchoReduction(micInput, output);
                
                // Update performance metrics
                this.metrics.processingLatency = performance.now() - startTime;
                this.updateMetrics();
            }
            
            applyAdaptiveFilter(micInput, systemInput, output) {
                // Normalized Least Mean Squares (NLMS) adaptive filter
                const mu = this.params.adaptiveGain;
                const filterLength = 128;
                
                if (!this.adaptiveWeights) {
                    this.adaptiveWeights = new Float32Array(filterLength);
                    this.systemHistory = new Float32Array(filterLength);
                }
                
                for (let i = 0; i < micInput.length; i++) {
                    // Shift system audio history
                    for (let j = filterLength - 1; j > 0; j--) {
                        this.systemHistory[j] = this.systemHistory[j - 1];
                    }
                    this.systemHistory[0] = systemInput[i];
                    
                    // Calculate predicted echo
                    let echo = 0;
                    for (let j = 0; j < filterLength; j++) {
                        echo += this.adaptiveWeights[j] * this.systemHistory[j];
                    }
                    
                    // Calculate error (desired signal)
                    const error = micInput[i] - echo;
                    output[i] = error;
                    
                    // Update filter weights
                    const norm = this.calculateNorm(this.systemHistory) + 1e-10;
                    for (let j = 0; j < filterLength; j++) {
                        this.adaptiveWeights[j] += (mu * error * this.systemHistory[j]) / norm;
                    }
                }
                
                // Store echo for visualization
                for (let i = 0; i < micInput.length; i++) {
                    let echo = 0;
                    for (let j = 0; j < filterLength && j < this.systemHistory.length; j++) {
                        echo += this.adaptiveWeights[j] * this.systemHistory[j];
                    }
                    this.echoBuffer[i] = echo;
                }
            }
            
            applySpectralSubtraction(micInput, systemInput, output) {
                // Simple spectral subtraction implementation
                const alpha = this.params.spectralSubtraction;
                
                for (let i = 0; i < micInput.length; i++) {
                    const estimatedNoise = systemInput[i] * alpha;
                    const subtracted = micInput[i] - estimatedNoise;
                    
                    // Apply spectral floor to prevent over-subtraction
                    const spectralFloor = 0.1 * Math.abs(micInput[i]);
                    output[i] = Math.sign(subtracted) * Math.max(Math.abs(subtracted), spectralFloor);
                    
                    this.echoBuffer[i] = estimatedNoise;
                }
            }
            
            applyCrossCorrelation(micInput, systemInput, output) {
                // Cross-correlation based delay estimation and cancellation
                const maxDelay = 64;
                let maxCorr = 0;
                let bestDelay = 0;
                
                // Find optimal delay
                for (let delay = 0; delay < maxDelay; delay++) {
                    let correlation = 0;
                    let normMic = 0;
                    let normSys = 0;
                    
                    for (let i = delay; i < micInput.length; i++) {
                        correlation += micInput[i] * systemInput[i - delay];
                        normMic += micInput[i] * micInput[i];
                        normSys += systemInput[i - delay] * systemInput[i - delay];
                    }
                    
                    const normalizedCorr = correlation / (Math.sqrt(normMic * normSys) + 1e-10);
                    
                    if (Math.abs(normalizedCorr) > Math.abs(maxCorr)) {
                        maxCorr = normalizedCorr;
                        bestDelay = delay;
                    }
                }
                
                // Apply echo cancellation with optimal delay
                const gain = this.params.adaptiveGain * maxCorr;
                for (let i = 0; i < micInput.length; i++) {
                    const delayedIndex = i - bestDelay;
                    if (delayedIndex >= 0) {
                        const echo = gain * systemInput[delayedIndex];
                        output[i] = micInput[i] - echo;
                        this.echoBuffer[i] = echo;
                    } else {
                        output[i] = micInput[i];
                        this.echoBuffer[i] = 0;
                    }
                }
            }
            
            applyHybridProcessing(micInput, systemInput, output) {
                // Combine adaptive filtering with spectral subtraction
                const tempOutput = new Float32Array(micInput.length);
                
                // First apply adaptive filtering
                this.applyAdaptiveFilter(micInput, systemInput, tempOutput);
                
                // Then apply spectral subtraction on the result
                for (let i = 0; i < tempOutput.length; i++) {
                    const estimatedNoise = systemInput[i] * this.params.spectralSubtraction * 0.5;
                    const subtracted = tempOutput[i] - estimatedNoise;
                    const spectralFloor = 0.05 * Math.abs(tempOutput[i]);
                    output[i] = Math.sign(subtracted) * Math.max(Math.abs(subtracted), spectralFloor);
                }
            }
            
            applyNoiseGate(output) {
                const threshold = this.params.noiseGateThreshold;
                const ratio = 10; // 10:1 compression ratio
                
                for (let i = 0; i < output.length; i++) {
                    const amplitude = Math.abs(output[i]);
                    if (amplitude < threshold) {
                        output[i] *= amplitude / (threshold * ratio);
                    }
                }
            }
            
            calculateNorm(array) {
                let sum = 0;
                for (let i = 0; i < array.length; i++) {
                    sum += array[i] * array[i];
                }
                return Math.sqrt(sum);
            }
            
            calculateEchoReduction(original, processed) {
                let originalPower = 0;
                let processedPower = 0;
                
                for (let i = 0; i < original.length; i++) {
                    originalPower += original[i] * original[i];
                    processedPower += processed[i] * processed[i];
                }
                
                const reduction = originalPower > 0 ? 
                    (1 - processedPower / originalPower) * 100 : 0;
                
                this.metrics.echoReduction = Math.max(0, Math.min(100, reduction));
            }
            
            setupVisualization() {
                this.canvases = {
                    mic: document.getElementById('micCanvas'),
                    system: document.getElementById('systemCanvas'),
                    processed: document.getElementById('processedMicCanvas'),
                    echo: document.getElementById('echoCanvas')
                };
                
                this.contexts = {};
                Object.keys(this.canvases).forEach(key => {
                    this.contexts[key] = this.canvases[key].getContext('2d');
                });
            }
            
            startProcessingLoop() {
                const draw = () => {
                    this.drawVisualizations();
                    requestAnimationFrame(draw);
                };
                draw();
            }
            
            drawVisualizations() {
                if (!this.audioContext) return;
                
                // Draw microphone waveform
                if (this.micAnalyzer) {
                    this.drawWaveform(this.micAnalyzer, this.contexts.mic, '#4facfe');
                }
                
                // Draw system audio waveform
                if (this.systemAnalyzer) {
                    this.drawWaveform(this.systemAnalyzer, this.contexts.system, '#00f2fe');
                }
                
                // Draw processed microphone
                if (this.processedAnalyzer) {
                    this.drawWaveform(this.processedAnalyzer, this.contexts.processed, '#4facfe');
                }
                
                // Draw echo visualization
                this.drawEchoVisualization();
            }
            
            drawWaveform(analyzer, context, color) {
                const canvas = context.canvas;
                const bufferLength = analyzer.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                analyzer.getByteTimeDomainData(dataArray);
                
                context.fillStyle = 'rgba(0, 0, 0, 0.1)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.lineWidth = 2;
                context.strokeStyle = color;
                context.beginPath();
                
                const sliceWidth = canvas.width / bufferLength;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvas.height / 2;
                    
                    if (i === 0) {
                        context.moveTo(x, y);
                    } else {
                        context.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                context.stroke();
            }
            
            drawEchoVisualization() {
                const context = this.contexts.echo;
                const canvas = context.canvas;
                
                context.fillStyle = 'rgba(0, 0, 0, 0.1)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                if (this.echoBuffer) {
                    context.lineWidth = 2;
                    context.strokeStyle = '#ff6b6b';
                    context.beginPath();
                    
                    const sliceWidth = canvas.width / this.echoBuffer.length;
                    let x = 0;
                    
                    for (let i = 0; i < this.echoBuffer.length; i++) {
                        const v = (this.echoBuffer[i] + 1) / 2;
                        const y = v * canvas.height;
                        
                        if (i === 0) {
                            context.moveTo(x, y);
                        } else {
                            context.lineTo(x, y);
                        }
                        
                        x += sliceWidth;
                    }
                    
                    context.stroke();
                }
            }
            
            updateMetrics() {
                document.getElementById('echoReduction').textContent = 
                    Math.round(this.metrics.echoReduction) + '%';
                
                document.getElementById('snrImprovement').textContent = 
                    Math.round(this.metrics.echoReduction * 0.3) + ' dB';
                
                document.getElementById('processingLatency').textContent = 
                    Math.round(this.metrics.processingLatency) + ' ms';
                
                // Simulate CPU usage (in real implementation, this would be measured)
                const cpuUsage = Math.min(100, this.metrics.processingLatency * 2);
                document.getElementById('cpuUsage').textContent = Math.round(cpuUsage) + '%';
            }
            
            setProcessingMode(mode) {
                this.params.processingMode = mode;
                
                // Update UI
                document.querySelectorAll('[id^="mode"]').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById(`mode${mode.charAt(0).toUpperCase() + mode.slice(1)}`).classList.add('active');
                
                // Update algorithm description
                const descriptions = {
                    adaptive: 'Using Normalized Least Mean Squares (NLMS) adaptive filter to predict and subtract echo from microphone signal. The algorithm continuously adapts to acoustic coupling between system audio and microphone.',
                    spectral: 'Applying spectral subtraction to remove system audio components from microphone signal. Uses frequency domain analysis to identify and subtract noise components.',
                    crosscorr: 'Using cross-correlation to find optimal delay between system audio and microphone echo, then applying time-delayed subtraction for echo cancellation.',
                    hybrid: 'Combining adaptive filtering with spectral subtraction for robust echo cancellation. First applies adaptive filtering, then spectral subtraction for residual noise removal.'
                };
                
                document.getElementById('algorithmDescription').textContent = descriptions[mode];
                
                this.updateStatus(`üß† Switched to ${mode} mode`);
            }
            
            updateStatus(message) {
                const statusEl = document.getElementById('captureStatus');
                statusEl.innerHTML = message;
                
                // Add recording indicator if streams are active
                if (this.micStream && this.systemStream) {
                    statusEl.innerHTML = '<span class="recording-indicator"></span>' + message;
                }
            }
            
            stopAll() {
                if (this.micStream) {
                    this.micStream.getTracks().forEach(track => track.stop());
                    this.micStream = null;
                }
                
                if (this.systemStream) {
                    this.systemStream.getTracks().forEach(track => track.stop());
                    this.systemStream = null;
                }
                
                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }
                
                this.updateStatus('‚èπÔ∏è All streams stopped');
            }
        }
        
        // Helper classes for audio processing
        class AdaptiveFilter {
            constructor(audioContext) {
                this.audioContext = audioContext;
                this.filterLength = 128;
                this.weights = new Float32Array(this.filterLength);
                this.inputHistory = new Float32Array(this.filterLength);
                this.mu = 0.01; // Learning rate
            }
            
            process(input, reference) {
                // Shift input history
                for (let i = this.filterLength - 1; i > 0; i--) {
                    this.inputHistory[i] = this.inputHistory[i - 1];
                }
                this.inputHistory[0] = reference;
                
                // Calculate filter output
                let output = 0;
                for (let i = 0; i < this.filterLength; i++) {
                    output += this.weights[i] * this.inputHistory[i];
                }
                
                // Calculate error
                const error = input - output;
                
                // Update weights (LMS algorithm)
                const norm = this.calculateNorm(this.inputHistory) + 1e-10;
                for (let i = 0; i < this.filterLength; i++) {
                    this.weights[i] += (this.mu * error * this.inputHistory[i]) / norm;
                }
                
                return error;
            }
            
            calculateNorm(array) {
                let sum = 0;
                for (let i = 0; i < array.length; i++) {
                    sum += array[i] * array[i];
                }
                return Math.sqrt(sum);
            }
        }
        
        class NoiseGate {
            constructor(audioContext) {
                this.audioContext = audioContext;
                this.threshold = 0.1;
                this.ratio = 10;
                this.attack = 0.001;
                this.release = 0.1;
                this.envelope = 0;
            }
            
            process(input, threshold = this.threshold) {
                const amplitude = Math.abs(input);
                
                // Calculate target envelope
                const targetEnvelope = amplitude > threshold ? 1 : 0;
                
                // Apply attack/release
                if (targetEnvelope > this.envelope) {
                    this.envelope += (targetEnvelope - this.envelope) * this.attack;
                } else {
                    this.envelope += (targetEnvelope - this.envelope) * this.release;
                }
                
                // Apply gating
                if (amplitude < threshold) {
                    return input * this.envelope / this.ratio;
                }
                
                return input;
            }
        }
        
        class SpectralSubtractor {
            constructor(audioContext) {
                this.audioContext = audioContext;
                this.fftSize = 1024;
                this.overlapFactor = 0.5;
                this.window = this.createWindow(this.fftSize);
                this.noiseProfile = new Float32Array(this.fftSize / 2);
                this.spectralFloor = 0.1;
            }
            
            createWindow(size) {
                const window = new Float32Array(size);
                for (let i = 0; i < size; i++) {
                    window[i] = 0.5 - 0.5 * Math.cos(2 * Math.PI * i / (size - 1));
                }
                return window;
            }
            
            process(signal, noise, alpha = 0.3) {
                // This is a simplified version - real implementation would use FFT
                const output = new Float32Array(signal.length);
                
                for (let i = 0; i < signal.length; i++) {
                    const estimatedNoise = noise[i] * alpha;
                    const subtracted = signal[i] - estimatedNoise;
                    const floor = this.spectralFloor * Math.abs(signal[i]);
                    
                    output[i] = Math.sign(subtracted) * Math.max(Math.abs(subtracted), floor);
                }
                
                return output;
            }
        }
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            const separator = new AudioStreamSeparator();
            
            // Add some additional UI enhancements
            const buttons = document.querySelectorAll('button');
            buttons.forEach(button => {
                button.addEventListener('click', function() {
                    this.style.transform = 'scale(0.95)';
                    setTimeout(() => {
                        this.style.transform = '';
                    }, 100);
                });
            });
            
            // Add CSS for active button state
            const style = document.createElement('style');
            style.textContent = `
                .active {
                    background: linear-gradient(45deg, #00f2fe, #4facfe) !important;
                    box-shadow: 0 0 20px rgba(79, 172, 254, 0.6) !important;
                }
                
                .metric-value {
                    transition: all 0.3s ease;
                }
                
                .metric-value:hover {
                    transform: scale(1.1);
                }
                
                @media (max-width: 768px) {
                    .control-panel {
                        grid-template-columns: 1fr;
                    }
                    
                    .visualizer {
                        grid-template-columns: 1fr;
                    }
                    
                    .metrics {
                        grid-template-columns: repeat(2, 1fr);
                    }
                }
            `;
            document.head.appendChild(style);
        });
    </script>
</body>
</html>